from pyModbusTCP.client import ModbusClient
import time

def read_holding_register(client, register_address, count=1):
    registers = client.read_holding_registers(register_address, count)
    return registers[0] if registers else None

def read_input_registers(client, start_address=0, count=10):
    registers = client.read_input_registers(start_address, count)
    if registers:
        print(f"Input Registers from {start_address} to {start_address + count - 1}:")
        for i, value in enumerate(registers):
            print(f"Register {start_address + i}: {value}")
    else:
        print("Failed to read input registers or no data returned.")

def write_register(client, register_address, value):
    return client.write_single_register(register_address, value)

if __name__ == "__main__":
    target_ip = "163.172.68.42"
    port = 10016
    slave_id = 105
    register_address = 10
    value_to_write = 255

    client = ModbusClient(host=target_ip, port=port, unit_id=slave_id, timeout=3)

    if not client.open():
        print("Unable to connect to Modbus server.")
    else:
        print("Connected to Modbus server.")

        initial_value = read_holding_register(client, register_address)
        print(f"Register {register_address}: {initial_value}")

        if write_register(client, register_address, value_to_write):
            print(f"Successfully wrote {value_to_write} to Register {register_address}.")
        else:
            print(f"Failed to write value {value_to_write} to Register {register_address}.")

        time.sleep(1)
        new_value = read_holding_register(client, register_address)
        print(f"Register {register_address}: {new_value}")

        time.sleep(1)
        read_input_registers(client, start_address=0, count=125)

        client.close()
        print("\nConnection closed.")
